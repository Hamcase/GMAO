'use client';

import { useMemo, useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@kit/ui/card';
import { Button } from '@kit/ui/button';
import { Badge } from '@kit/ui/badge';
import { Sparkles, AlertCircle, TrendingUp, Wrench, DollarSign, Clock } from 'lucide-react';
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@kit/ui/table';

interface AMDECAnalysisRow {
  component: string;
  failureType: string;
  frequency: number;
  severity: number;
  detectability: number;
  rpn: number;
  action: string;
}

export function AMDECAITab({
  amdecRawData,
  filterMachine,
  aiEnabled,
  onAnalysisGenerated,
}: {
  amdecRawData: any[];
  filterMachine: string;
  aiEnabled: boolean;
  onAnalysisGenerated?: (analysis: AMDECAnalysisRow[]) => void;
}) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [analysis, setAnalysis] = useState<AMDECAnalysisRow[] | null>(null);

  const filteredData = filterMachine === 'all' 
    ? amdecRawData 
    : amdecRawData.filter((r: any) => r.machine === filterMachine);

  // Calculate machine summary statistics
  const machineSummary = useMemo(() => {
    const failureTypes = new Map<string, number>();
    const components = new Map<string, { count: number; cost: number; downtime: number }>();
    let totalCost = 0;
    let totalDowntime = 0;

    filteredData.forEach((record: any) => {
      // Count failure types
      if (record.failureType) {
        failureTypes.set(record.failureType, (failureTypes.get(record.failureType) || 0) + 1);
      }

      // Aggregate by component
      if (record.component) {
        const current = components.get(record.component) || { count: 0, cost: 0, downtime: 0 };
        components.set(record.component, {
          count: current.count + 1,
          cost: current.cost + (record.materialCost || 0),
          downtime: current.downtime + (record.downtimeDuration || 0),
        });
      }

      totalCost += record.materialCost || 0;
      totalDowntime += record.downtimeDuration || 0;
    });

    return {
      totalRecords: filteredData.length,
      failureTypes: Array.from(failureTypes.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10),
      components: Array.from(components.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 10),
      totalCost,
      totalDowntime,
    };
  }, [filteredData]);

  const generateAnalysis = async () => {
    if (!aiEnabled) return;
    
    setIsGenerating(true);
    try {
      // Try Groq API first
      const response = await fetch('/api/amdec/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          data: filteredData, 
          machine: filterMachine 
        }),
      });

      if (response.ok) {
        const { results } = await response.json();
        console.log('üîç API Response:', { resultsCount: results?.length, results });
        
        if (!results || results.length === 0) {
          console.warn('‚ö†Ô∏è API returned empty results, falling back to rule-based');
          throw new Error('Empty results from API');
        }
        
        // Map results to AMDECAnalysisRow format
        const analysisResults: AMDECAnalysisRow[] = results.map((item: any) => ({
          component: item.component,
          failureType: item.failureType,
          frequency: item.F,
          severity: item.G,
          detectability: item.D,
          rpn: item.F * item.G * item.D,
          action: item.action,
        }));

        analysisResults.sort((a, b) => b.rpn - a.rpn);
        setAnalysis(analysisResults);
        onAnalysisGenerated?.(analysisResults); // Notify parent
        setIsGenerating(false);
        console.log('‚úÖ AMDEC analysis generated by Groq AI:', analysisResults.length, 'results');
        return;
      } else {
        console.warn('Groq API not available, using rule-based fallback');
      }
    } catch (error) {
      console.warn('Groq API error, using rule-based fallback:', error);
    }

    // Fallback: Rule-based scoring if Groq fails
    try {
      // Aggregate data by component + failureType
      const aggregated = new Map<string, {
        component: string;
        failureType: string;
        count: number;
        totalCost: number;
        totalDowntime: number;
      }>();

      filteredData.forEach((r: any) => {
        if (!r.component || !r.failureType) return;
        const key = `${r.component}|${r.failureType}`;
        const current = aggregated.get(key) || {
          component: r.component,
          failureType: r.failureType,
          count: 0,
          totalCost: 0,
          totalDowntime: 0,
        };
        aggregated.set(key, {
          ...current,
          count: current.count + 1,
          totalCost: current.totalCost + (r.materialCost || 0),
          totalDowntime: current.totalDowntime + (r.downtimeDuration || 0),
        });
      });

      const aggregatedList = Array.from(aggregated.values())
        .sort((a, b) => b.count - a.count)
        .slice(0, 20); // Top 20 failure modes

      // TODO: Replace with real Groq API call
      // For now, use rule-based scoring (1-5 scale)
      const analysisResults: AMDECAnalysisRow[] = aggregatedList.map(item => {
        // F (Frequency): Based on occurrence count (1-5 scale)
        const F = item.count >= 50 ? 5 : item.count >= 30 ? 4 : item.count >= 15 ? 3 : item.count >= 5 ? 2 : 1;
        
        // G (Severity/Gravity): Based on cost + downtime (1-5 scale)
        const impactScore = item.totalCost / 1000 + item.totalDowntime * 10;
        const G = impactScore >= 3000 ? 5 : impactScore >= 1500 ? 4 : impactScore >= 500 ? 3 : impactScore >= 100 ? 2 : 1;
        
        // D (Detectability): Default moderate, could be enhanced by AI (1-5 scale, 5 = hard to detect)
        const D = 3;

        const rpn = F * G * D;

        // Generate action based on RPN (max RPN = 5*5*5 = 125)
        let action = '';
        if (rpn >= 75) {
          action = 'Action imm√©diate: Maintenance pr√©ventive renforc√©e + analyse des causes racines';
        } else if (rpn >= 40) {
          action = 'Action √† planifier: Am√©liorer la surveillance + formation √©quipes';
        } else if (rpn >= 20) {
          action = 'Surveillance renforc√©e: Documenter et suivre';
        } else {
          action = 'Surveillance continue: Documenter les occurrences';
        }

        return {
          component: item.component,
          failureType: item.failureType,
          frequency: F,
          severity: G,
          detectability: D,
          rpn,
          action,
        };
      });

      // Sort by RPN descending
      analysisResults.sort((a, b) => b.rpn - a.rpn);
      
      setAnalysis(analysisResults);
      onAnalysisGenerated?.(analysisResults); // Notify parent
      setIsGenerating(false);
    } catch (error) {
      console.error('Erreur g√©n√©ration AMDEC:', error);
      setIsGenerating(false);
    }
  };

  if (!filteredData.length) {
    return (
      <Card>
        <CardContent className="flex h-64 items-center justify-center">
          <div className="text-center">
            <Sparkles className="mx-auto h-12 w-12 text-muted-foreground/50" />
            <p className="mt-4 text-sm text-muted-foreground">
              Aucune donn√©e disponible. Importez un CSV d'abord.
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  const getRPNColor = (rpn: number) => {
    if (rpn >= 75) return 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-200';
    if (rpn >= 40) return 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-200';
    if (rpn >= 20) return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-200';
    return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-200';
  };

  return (
    <div className="space-y-6">
      {/* Machine Summary KPIs */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <Card className="border-l-4 border-l-teal-500">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              Pannes totales
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{machineSummary.totalRecords}</div>
            <p className="text-xs text-muted-foreground">
              {filterMachine === 'all' ? 'Toutes machines' : filterMachine}
            </p>
          </CardContent>
        </Card>

        <Card className="border-l-4 border-l-cyan-500">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm flex items-center gap-2">
              <TrendingUp className="h-4 w-4" />
              Types de pannes
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{machineSummary.failureTypes.length}</div>
            <p className="text-xs text-muted-foreground">Modes distincts</p>
          </CardContent>
        </Card>

        <Card className="border-l-4 border-l-emerald-500">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm flex items-center gap-2">
              <Clock className="h-4 w-4" />
              Arr√™ts cumul√©s
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{Math.round(machineSummary.totalDowntime)}h</div>
            <p className="text-xs text-muted-foreground">Dur√©e totale</p>
          </CardContent>
        </Card>

        <Card className="border-l-4 border-l-rose-500">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm flex items-center gap-2">
              <DollarSign className="h-4 w-4" />
              Co√ªt total
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{Math.round(machineSummary.totalCost).toLocaleString()}‚Ç¨</div>
            <p className="text-xs text-muted-foreground">Mat√©riel</p>
          </CardContent>
        </Card>
      </div>

      {/* Top Failure Types */}
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Types de pannes les plus fr√©quents</CardTitle>
          <CardDescription>Top 10 par occurrence</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {machineSummary.failureTypes.map(([type, count], index) => (
              <div key={type} className="flex items-center justify-between p-2 rounded-lg bg-muted/50">
                <div className="flex items-center gap-3">
                  <Badge variant="outline" className="font-mono">{index + 1}</Badge>
                  <span className="text-sm font-medium">{type}</span>
                </div>
                <Badge>{count} occurrences</Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Top Components */}
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Composants critiques</CardTitle>
          <CardDescription>Top 10 par nombre de pannes</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {machineSummary.components.map(([component, stats], index) => (
              <div key={component} className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                <div className="flex items-center gap-3">
                  <Badge variant="outline" className="font-mono">{index + 1}</Badge>
                  <div>
                    <p className="text-sm font-medium">{component}</p>
                    <p className="text-xs text-muted-foreground">
                      {Math.round(stats.downtime)}h arr√™t ‚Ä¢ {Math.round(stats.cost)}‚Ç¨
                    </p>
                  </div>
                </div>
                <Badge>{stats.count} pannes</Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* AI Analysis Generator */}
      <Card className="border-teal-200 dark:border-teal-800">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Sparkles className="h-5 w-5 text-teal-600" />
            G√©n√©ration de l'analyse AMDEC avec IA
          </CardTitle>
          <CardDescription>
            Calcul automatique de F (Fr√©quence), G (Gravit√©), D (D√©tectabilit√©) et suggestions d'actions
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="rounded-lg bg-teal-50 dark:bg-teal-900/20 p-4">
            <p className="text-sm text-teal-800 dark:text-teal-200">
              <strong>{filteredData.length} lignes</strong> pr√™tes pour l'analyse IA.
            </p>
            <p className="text-xs text-teal-700 dark:text-teal-300 mt-1">
              ‚ú® <strong>Groq AI activ√©!</strong> L'IA analysera les donn√©es historiques pour calculer intelligemment les scores F/G/D et proposer des actions correctives adapt√©es.
            </p>
            <p className="text-xs text-teal-600 dark:text-teal-400">
              Mode de secours rule-based disponible si l'API est indisponible.
            </p>
          </div>

          <Button 
            onClick={generateAnalysis} 
            disabled={!aiEnabled || isGenerating}
            className="w-full gap-2"
            size="lg"
          >
            <Sparkles className="h-4 w-4" />
            {isGenerating ? 'G√©n√©ration en cours...' : 'G√©n√©rer l\'analyse AMDEC'}
          </Button>

          {!aiEnabled && (
            <div className="rounded-lg border border-amber-200 bg-amber-50 dark:bg-amber-900/20 p-3 text-sm text-amber-800 dark:text-amber-200">
              <AlertCircle className="inline h-4 w-4 mr-2" />
              L'assistance IA est d√©sactiv√©e. Activez-la dans le header pour utiliser cette fonctionnalit√©.
            </div>
          )}

          {analysis && (
            <Card className="border-emerald-200 dark:border-emerald-800">
              <CardHeader>
                <CardTitle className="text-base">Tableau d'analyse AMDEC</CardTitle>
                <CardDescription>
                  Class√© par criticit√© (RPN = F √ó G √ó D)
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="rounded-lg border overflow-hidden">
                  <Table>
                    <TableHeader>
                      <TableRow className="bg-muted/50">
                        <TableHead className="font-semibold">Composant</TableHead>
                        <TableHead className="font-semibold">Mode de d√©faillance</TableHead>
                        <TableHead className="font-semibold text-center w-16">F</TableHead>
                        <TableHead className="font-semibold text-center w-16">G</TableHead>
                        <TableHead className="font-semibold text-center w-16">D</TableHead>
                        <TableHead className="font-semibold text-center w-20">RPN</TableHead>
                        <TableHead className="font-semibold">Action recommand√©e</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {analysis.map((row, idx) => (
                        <TableRow key={idx}>
                          <TableCell className="font-medium">{row.component}</TableCell>
                          <TableCell>{row.failureType}</TableCell>
                          <TableCell className="text-center">{row.frequency}</TableCell>
                          <TableCell className="text-center">{row.severity}</TableCell>
                          <TableCell className="text-center">{row.detectability}</TableCell>
                          <TableCell className="text-center">
                            <Badge className={getRPNColor(row.rpn)}>
                              {row.rpn}
                            </Badge>
                          </TableCell>
                          <TableCell className="text-xs">{row.action}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
                <div className="mt-4 text-xs text-muted-foreground">
                  <strong>L√©gende:</strong> F = Fr√©quence (1-5), G = Gravit√© (1-5), D = D√©tectabilit√© (1-5), RPN = Risque Prioritaire (F√óG√óD, max 125).
                  <br />
                  <span className="text-red-600 dark:text-red-400 font-semibold">RPN ‚â• 75</span> = Critique | 
                  <span className="text-orange-600 dark:text-orange-400 font-semibold ml-2">RPN 40-74</span> = Majeur | 
                  <span className="text-yellow-600 dark:text-yellow-400 font-semibold ml-2">RPN 20-39</span> = Mod√©r√© |
                  <span className="text-green-600 dark:text-green-400 font-semibold ml-2">RPN &lt; 20</span> = Mineur
                </div>
              </CardContent>
            </Card>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
